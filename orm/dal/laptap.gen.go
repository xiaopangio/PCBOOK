// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/xiaopangio/pcbook/orm/model"
)

func newLaptap(db *gorm.DB, opts ...gen.DOOption) laptap {
	_laptap := laptap{}

	_laptap.laptapDo.UseDB(db, opts...)
	_laptap.laptapDo.UseModel(&model.Laptap{})

	tableName := _laptap.laptapDo.TableName()
	_laptap.ALL = field.NewAsterisk(tableName)
	_laptap.LaptapID = field.NewString(tableName, "laptap_id")
	_laptap.Brand = field.NewString(tableName, "brand")
	_laptap.Name = field.NewString(tableName, "name")
	_laptap.CPUID = field.NewInt32(tableName, "cpu_id")
	_laptap.RAMID = field.NewInt32(tableName, "ram_id")
	_laptap.ScreenID = field.NewInt32(tableName, "screen_id")
	_laptap.KeyboardID = field.NewInt32(tableName, "keyboard_id")
	_laptap.WeightID = field.NewInt32(tableName, "weight_id")
	_laptap.PriceUsd = field.NewFloat32(tableName, "price_usd")
	_laptap.ReleaseYear = field.NewInt32(tableName, "release_year")
	_laptap.UpdateAt = field.NewTime(tableName, "update_at")
	_laptap.CPU = laptapHasOneCPU{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("CPU", "model.CPU"),
	}

	_laptap.RAM = laptapHasOneRAM{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("RAM", "model.Memory"),
		Unit: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("RAM.Unit", "model.MemoryUnit"),
		},
	}

	_laptap.Screen = laptapHasOneScreen{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Screen", "model.Screen"),
		Resolution: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Screen.Resolution", "model.ScreenResolution"),
		},
		Panel: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Screen.Panel", "model.ScreenPanel"),
		},
	}

	_laptap.Keyboard = laptapHasOneKeyboard{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Keyboard", "model.Keyboard"),
		Layout: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Keyboard.Layout", "model.KeyboardLayout"),
		},
	}

	_laptap.Weight = laptapHasOneWeight{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Weight", "model.Weight"),
		Unit: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Weight.Unit", "model.WeightUnit"),
		},
	}

	_laptap.GPUS = laptapHasManyGPUS{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("GPUS", "model.LaptapGpu"),
		Gpu: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("GPUS.Gpu", "model.Gpu"),
		},
	}

	_laptap.Storages = laptapHasManyStorages{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Storages", "model.LaptapStorage"),
		Storage: struct {
			field.RelationField
			Driver struct {
				field.RelationField
			}
			Memory struct {
				field.RelationField
				Unit struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("Storages.Storage", "model.Storage"),
			Driver: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Storages.Storage.Driver", "model.StorageDriver"),
			},
			Memory: struct {
				field.RelationField
				Unit struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Storages.Storage.Memory", "model.Memory"),
				Unit: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Storages.Storage.Memory.Unit", "model.MemoryUnit"),
				},
			},
		},
	}

	_laptap.fillFieldMap()

	return _laptap
}

type laptap struct {
	laptapDo

	ALL         field.Asterisk
	LaptapID    field.String
	Brand       field.String
	Name        field.String
	CPUID       field.Int32
	RAMID       field.Int32
	ScreenID    field.Int32
	KeyboardID  field.Int32
	WeightID    field.Int32
	PriceUsd    field.Float32
	ReleaseYear field.Int32
	UpdateAt    field.Time
	CPU         laptapHasOneCPU

	RAM laptapHasOneRAM

	Screen laptapHasOneScreen

	Keyboard laptapHasOneKeyboard

	Weight laptapHasOneWeight

	GPUS laptapHasManyGPUS

	Storages laptapHasManyStorages

	fieldMap map[string]field.Expr
}

func (l laptap) Table(newTableName string) *laptap {
	l.laptapDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l laptap) As(alias string) *laptap {
	l.laptapDo.DO = *(l.laptapDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *laptap) updateTableName(table string) *laptap {
	l.ALL = field.NewAsterisk(table)
	l.LaptapID = field.NewString(table, "laptap_id")
	l.Brand = field.NewString(table, "brand")
	l.Name = field.NewString(table, "name")
	l.CPUID = field.NewInt32(table, "cpu_id")
	l.RAMID = field.NewInt32(table, "ram_id")
	l.ScreenID = field.NewInt32(table, "screen_id")
	l.KeyboardID = field.NewInt32(table, "keyboard_id")
	l.WeightID = field.NewInt32(table, "weight_id")
	l.PriceUsd = field.NewFloat32(table, "price_usd")
	l.ReleaseYear = field.NewInt32(table, "release_year")
	l.UpdateAt = field.NewTime(table, "update_at")

	l.fillFieldMap()

	return l
}

func (l *laptap) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *laptap) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 18)
	l.fieldMap["laptap_id"] = l.LaptapID
	l.fieldMap["brand"] = l.Brand
	l.fieldMap["name"] = l.Name
	l.fieldMap["cpu_id"] = l.CPUID
	l.fieldMap["ram_id"] = l.RAMID
	l.fieldMap["screen_id"] = l.ScreenID
	l.fieldMap["keyboard_id"] = l.KeyboardID
	l.fieldMap["weight_id"] = l.WeightID
	l.fieldMap["price_usd"] = l.PriceUsd
	l.fieldMap["release_year"] = l.ReleaseYear
	l.fieldMap["update_at"] = l.UpdateAt

}

func (l laptap) clone(db *gorm.DB) laptap {
	l.laptapDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l laptap) replaceDB(db *gorm.DB) laptap {
	l.laptapDo.ReplaceDB(db)
	return l
}

type laptapHasOneCPU struct {
	db *gorm.DB

	field.RelationField
}

func (a laptapHasOneCPU) Where(conds ...field.Expr) *laptapHasOneCPU {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a laptapHasOneCPU) WithContext(ctx context.Context) *laptapHasOneCPU {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a laptapHasOneCPU) Model(m *model.Laptap) *laptapHasOneCPUTx {
	return &laptapHasOneCPUTx{a.db.Model(m).Association(a.Name())}
}

type laptapHasOneCPUTx struct{ tx *gorm.Association }

func (a laptapHasOneCPUTx) Find() (result *model.CPU, err error) {
	return result, a.tx.Find(&result)
}

func (a laptapHasOneCPUTx) Append(values ...*model.CPU) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a laptapHasOneCPUTx) Replace(values ...*model.CPU) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a laptapHasOneCPUTx) Delete(values ...*model.CPU) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a laptapHasOneCPUTx) Clear() error {
	return a.tx.Clear()
}

func (a laptapHasOneCPUTx) Count() int64 {
	return a.tx.Count()
}

type laptapHasOneRAM struct {
	db *gorm.DB

	field.RelationField

	Unit struct {
		field.RelationField
	}
}

func (a laptapHasOneRAM) Where(conds ...field.Expr) *laptapHasOneRAM {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a laptapHasOneRAM) WithContext(ctx context.Context) *laptapHasOneRAM {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a laptapHasOneRAM) Model(m *model.Laptap) *laptapHasOneRAMTx {
	return &laptapHasOneRAMTx{a.db.Model(m).Association(a.Name())}
}

type laptapHasOneRAMTx struct{ tx *gorm.Association }

func (a laptapHasOneRAMTx) Find() (result *model.Memory, err error) {
	return result, a.tx.Find(&result)
}

func (a laptapHasOneRAMTx) Append(values ...*model.Memory) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a laptapHasOneRAMTx) Replace(values ...*model.Memory) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a laptapHasOneRAMTx) Delete(values ...*model.Memory) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a laptapHasOneRAMTx) Clear() error {
	return a.tx.Clear()
}

func (a laptapHasOneRAMTx) Count() int64 {
	return a.tx.Count()
}

type laptapHasOneScreen struct {
	db *gorm.DB

	field.RelationField

	Resolution struct {
		field.RelationField
	}
	Panel struct {
		field.RelationField
	}
}

func (a laptapHasOneScreen) Where(conds ...field.Expr) *laptapHasOneScreen {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a laptapHasOneScreen) WithContext(ctx context.Context) *laptapHasOneScreen {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a laptapHasOneScreen) Model(m *model.Laptap) *laptapHasOneScreenTx {
	return &laptapHasOneScreenTx{a.db.Model(m).Association(a.Name())}
}

type laptapHasOneScreenTx struct{ tx *gorm.Association }

func (a laptapHasOneScreenTx) Find() (result *model.Screen, err error) {
	return result, a.tx.Find(&result)
}

func (a laptapHasOneScreenTx) Append(values ...*model.Screen) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a laptapHasOneScreenTx) Replace(values ...*model.Screen) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a laptapHasOneScreenTx) Delete(values ...*model.Screen) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a laptapHasOneScreenTx) Clear() error {
	return a.tx.Clear()
}

func (a laptapHasOneScreenTx) Count() int64 {
	return a.tx.Count()
}

type laptapHasOneKeyboard struct {
	db *gorm.DB

	field.RelationField

	Layout struct {
		field.RelationField
	}
}

func (a laptapHasOneKeyboard) Where(conds ...field.Expr) *laptapHasOneKeyboard {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a laptapHasOneKeyboard) WithContext(ctx context.Context) *laptapHasOneKeyboard {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a laptapHasOneKeyboard) Model(m *model.Laptap) *laptapHasOneKeyboardTx {
	return &laptapHasOneKeyboardTx{a.db.Model(m).Association(a.Name())}
}

type laptapHasOneKeyboardTx struct{ tx *gorm.Association }

func (a laptapHasOneKeyboardTx) Find() (result *model.Keyboard, err error) {
	return result, a.tx.Find(&result)
}

func (a laptapHasOneKeyboardTx) Append(values ...*model.Keyboard) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a laptapHasOneKeyboardTx) Replace(values ...*model.Keyboard) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a laptapHasOneKeyboardTx) Delete(values ...*model.Keyboard) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a laptapHasOneKeyboardTx) Clear() error {
	return a.tx.Clear()
}

func (a laptapHasOneKeyboardTx) Count() int64 {
	return a.tx.Count()
}

type laptapHasOneWeight struct {
	db *gorm.DB

	field.RelationField

	Unit struct {
		field.RelationField
	}
}

func (a laptapHasOneWeight) Where(conds ...field.Expr) *laptapHasOneWeight {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a laptapHasOneWeight) WithContext(ctx context.Context) *laptapHasOneWeight {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a laptapHasOneWeight) Model(m *model.Laptap) *laptapHasOneWeightTx {
	return &laptapHasOneWeightTx{a.db.Model(m).Association(a.Name())}
}

type laptapHasOneWeightTx struct{ tx *gorm.Association }

func (a laptapHasOneWeightTx) Find() (result *model.Weight, err error) {
	return result, a.tx.Find(&result)
}

func (a laptapHasOneWeightTx) Append(values ...*model.Weight) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a laptapHasOneWeightTx) Replace(values ...*model.Weight) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a laptapHasOneWeightTx) Delete(values ...*model.Weight) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a laptapHasOneWeightTx) Clear() error {
	return a.tx.Clear()
}

func (a laptapHasOneWeightTx) Count() int64 {
	return a.tx.Count()
}

type laptapHasManyGPUS struct {
	db *gorm.DB

	field.RelationField

	Gpu struct {
		field.RelationField
	}
}

func (a laptapHasManyGPUS) Where(conds ...field.Expr) *laptapHasManyGPUS {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a laptapHasManyGPUS) WithContext(ctx context.Context) *laptapHasManyGPUS {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a laptapHasManyGPUS) Model(m *model.Laptap) *laptapHasManyGPUSTx {
	return &laptapHasManyGPUSTx{a.db.Model(m).Association(a.Name())}
}

type laptapHasManyGPUSTx struct{ tx *gorm.Association }

func (a laptapHasManyGPUSTx) Find() (result []*model.LaptapGpu, err error) {
	return result, a.tx.Find(&result)
}

func (a laptapHasManyGPUSTx) Append(values ...*model.LaptapGpu) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a laptapHasManyGPUSTx) Replace(values ...*model.LaptapGpu) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a laptapHasManyGPUSTx) Delete(values ...*model.LaptapGpu) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a laptapHasManyGPUSTx) Clear() error {
	return a.tx.Clear()
}

func (a laptapHasManyGPUSTx) Count() int64 {
	return a.tx.Count()
}

type laptapHasManyStorages struct {
	db *gorm.DB

	field.RelationField

	Storage struct {
		field.RelationField
		Driver struct {
			field.RelationField
		}
		Memory struct {
			field.RelationField
			Unit struct {
				field.RelationField
			}
		}
	}
}

func (a laptapHasManyStorages) Where(conds ...field.Expr) *laptapHasManyStorages {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a laptapHasManyStorages) WithContext(ctx context.Context) *laptapHasManyStorages {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a laptapHasManyStorages) Model(m *model.Laptap) *laptapHasManyStoragesTx {
	return &laptapHasManyStoragesTx{a.db.Model(m).Association(a.Name())}
}

type laptapHasManyStoragesTx struct{ tx *gorm.Association }

func (a laptapHasManyStoragesTx) Find() (result []*model.LaptapStorage, err error) {
	return result, a.tx.Find(&result)
}

func (a laptapHasManyStoragesTx) Append(values ...*model.LaptapStorage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a laptapHasManyStoragesTx) Replace(values ...*model.LaptapStorage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a laptapHasManyStoragesTx) Delete(values ...*model.LaptapStorage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a laptapHasManyStoragesTx) Clear() error {
	return a.tx.Clear()
}

func (a laptapHasManyStoragesTx) Count() int64 {
	return a.tx.Count()
}

type laptapDo struct{ gen.DO }

func (l laptapDo) Debug() *laptapDo {
	return l.withDO(l.DO.Debug())
}

func (l laptapDo) WithContext(ctx context.Context) *laptapDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l laptapDo) ReadDB() *laptapDo {
	return l.Clauses(dbresolver.Read)
}

func (l laptapDo) WriteDB() *laptapDo {
	return l.Clauses(dbresolver.Write)
}

func (l laptapDo) Session(config *gorm.Session) *laptapDo {
	return l.withDO(l.DO.Session(config))
}

func (l laptapDo) Clauses(conds ...clause.Expression) *laptapDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l laptapDo) Returning(value interface{}, columns ...string) *laptapDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l laptapDo) Not(conds ...gen.Condition) *laptapDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l laptapDo) Or(conds ...gen.Condition) *laptapDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l laptapDo) Select(conds ...field.Expr) *laptapDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l laptapDo) Where(conds ...gen.Condition) *laptapDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l laptapDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *laptapDo {
	return l.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (l laptapDo) Order(conds ...field.Expr) *laptapDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l laptapDo) Distinct(cols ...field.Expr) *laptapDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l laptapDo) Omit(cols ...field.Expr) *laptapDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l laptapDo) Join(table schema.Tabler, on ...field.Expr) *laptapDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l laptapDo) LeftJoin(table schema.Tabler, on ...field.Expr) *laptapDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l laptapDo) RightJoin(table schema.Tabler, on ...field.Expr) *laptapDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l laptapDo) Group(cols ...field.Expr) *laptapDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l laptapDo) Having(conds ...gen.Condition) *laptapDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l laptapDo) Limit(limit int) *laptapDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l laptapDo) Offset(offset int) *laptapDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l laptapDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *laptapDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l laptapDo) Unscoped() *laptapDo {
	return l.withDO(l.DO.Unscoped())
}

func (l laptapDo) Create(values ...*model.Laptap) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l laptapDo) CreateInBatches(values []*model.Laptap, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l laptapDo) Save(values ...*model.Laptap) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l laptapDo) First() (*model.Laptap, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Laptap), nil
	}
}

func (l laptapDo) Take() (*model.Laptap, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Laptap), nil
	}
}

func (l laptapDo) Last() (*model.Laptap, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Laptap), nil
	}
}

func (l laptapDo) Find() ([]*model.Laptap, error) {
	result, err := l.DO.Find()
	return result.([]*model.Laptap), err
}

func (l laptapDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Laptap, err error) {
	buf := make([]*model.Laptap, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l laptapDo) FindInBatches(result *[]*model.Laptap, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l laptapDo) Attrs(attrs ...field.AssignExpr) *laptapDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l laptapDo) Assign(attrs ...field.AssignExpr) *laptapDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l laptapDo) Joins(fields ...field.RelationField) *laptapDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l laptapDo) Preload(fields ...field.RelationField) *laptapDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l laptapDo) FirstOrInit() (*model.Laptap, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Laptap), nil
	}
}

func (l laptapDo) FirstOrCreate() (*model.Laptap, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Laptap), nil
	}
}

func (l laptapDo) FindByPage(offset int, limit int) (result []*model.Laptap, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l laptapDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l laptapDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l laptapDo) Delete(models ...*model.Laptap) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *laptapDo) withDO(do gen.Dao) *laptapDo {
	l.DO = *do.(*gen.DO)
	return l
}
